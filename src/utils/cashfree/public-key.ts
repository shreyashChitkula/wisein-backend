import { HttpException, HttpStatus, Logger } from '@nestjs/common';
import * as crypto from 'crypto';

/**
 * Generate Cashfree API signature using RSA public key encryption
 * This function creates a signature required by Cashfree DigiLocker API
 * 
 * The signature is generated by:
 * 1. Creating encoded data: `${clientId}.${timestamp}`
 * 2. Encrypting it using RSA public key with OAEP-SHA1 padding
 * 3. Converting the result to base64
 * 
 * This matches Cashfree's Java implementation: RSA/ECB/OAEPWithSHA-1AndMGF1Padding
 */
export function getCashfreeSignature(clientId: string, publicKeyEnv: string): string {
  if (!clientId || !publicKeyEnv) {
    throw new HttpException(
      'Cashfree API key or public key is not set',
      HttpStatus.INTERNAL_SERVER_ERROR
    );
  }

  const logger = new Logger('CashfreeSignature');
  logger.debug('Generating Cashfree signature');

  const timestamp = Math.floor(Date.now() / 1000);
  const encodedData = `${clientId}.${timestamp}`;
  const bufferToEncrypt = Buffer.from(encodedData);

  // Format the public key - handle both escaped \n and actual newlines
  let formattedKey = publicKeyEnv.trim();

  // Check if the key has literal \n (as string) that need to be converted to actual newlines
  if (formattedKey.includes('\\n')) {
    formattedKey = formattedKey.replace(/\\n/g, '\n');
    logger.debug('Replaced \\n with actual newlines');
  }

  // If the key is all on one line (no newlines), we need to format it properly
  if (!formattedKey.includes('\n') && formattedKey.includes('-----BEGIN PUBLIC KEY-----')) {
    logger.debug('Key is on single line, formatting it properly');

    // Extract the base64 content between the headers
    const keyContent = formattedKey
      .replace('-----BEGIN PUBLIC KEY-----', '')
      .replace('-----END PUBLIC KEY-----', '')
      .trim();

    // Split base64 content into 64-character lines (PEM format standard)
    const formattedContent = keyContent.match(/.{1,64}/g)?.join('\n') || keyContent;

    // Rebuild with proper newlines
    formattedKey = `-----BEGIN PUBLIC KEY-----\n${formattedContent}\n-----END PUBLIC KEY-----`;
  }

  try {
    // Using SHA-1 for OAEP as per Cashfree's Java example: RSA/ECB/OAEPWithSHA-1AndMGF1Padding
    const encrypted = crypto.publicEncrypt(
      {
        key: formattedKey,
        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
        oaepHash: 'sha1', // Cashfree uses SHA-1 for OAEP, not SHA-256
      },
      bufferToEncrypt
    );

    logger.debug(`Generated signature for data: ${encodedData}`);
    return encrypted.toString('base64');
  } catch (error) {
    logger.error('Failed to encrypt signature:', error.message);
    throw new HttpException(
      'Failed to generate API signature. Invalid public key format.',
      HttpStatus.INTERNAL_SERVER_ERROR
    );
  }
}
